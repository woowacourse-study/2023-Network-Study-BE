# Ch01. 웹 브라우저가 메시지를 만든다

## 01. HTTP 리퀘스트 메시지를 작성한다.

```
💡 URL 입력 → 브라우저가 URL 해독 → 해독한 URL을 통해 HTTP Request Message 작성
```

### URL

> **모든 URL의 공통점**: **맨 앞의 문자열에 프로토콜 종류가 쓰여있음**
> 
- 프로토콜의 종류: 액세스 하는 방법
- ex) `HTTP`, `FTP`, `FILE`, …
- 액세스 대상이 웹 서버라면 HTTP 프로토콜 사용

> **URL의 요소** (HTTP 프로토콜)
> 
- http://웹서버명/디렉토리명/.../파일명
    - `http:` : 데이터 출처에 액세스 하는 방법 = 프로토콜
    - `//` : 나중에 이어지는 문자열이 서버의 이름
    - `/디렉토리명/파일명`: 데이터 출처(파일)의 경로명

### HTTP

> **Request Message**
> 
- **리퀘스트 라인: `<메소드> <URI> <HTTP 버전>`**
    - **메소드**: 웹 서버에 어떤 동작을 하고 싶은지
    - **URI**: 액세스 대상을 통칭하는 말 (식별자)
- **메시지 헤더:** 부가적인 정보 (ex. 날짜,  데이터 종류, 언어 등등)
- **메시지 본문:** 송신할 데이터

> **Response Message**
> 
- **스테이터스 라인: `<HTTP 버전> <스테이터스 코드> <응답 문구>`**
- **메시지 헤더**
- **메시지 본문**
    - 이미지 혹은 영상을 나타내는 태그가 포함되어 있다면, 영상 부분은 공백으로 비어두고 표시
    - 다시 한번 웹 서버에 액세스 하여 태그에 쓰여 있는 파일을 가져와서 보여줌
    
    ⇒ 한 개의 리퀘스트에는 한 개의 응답만 보냄
    

## 02. 웹 서버의 IP 주소를 DNS 서버에 조회한다.

```
💡 도메인명에서 IP 주소 조사

- 브라우저는 메시지를 네트워크에 송출하는 기능은 없음
- HTTP 메시지를 OS에 의뢰하여 웹 서버에게 송신
- 이 때, 도메인명이 아닌 IP 주소로 지정해야함
```

### IP 주소

> **TCP/IP**
> 
- 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어짐
    - **서브넷**: 허브에 몇 대의 PC가 접속된 것
    - **라우터**: 패킷을 중계하는 장치의 일종
    - **허브**: 패킷을 중계하는 장치의 일종 (리피터 허브, 스위칭 허브)
    - 서브넷을 라우터에서 연결하면 네트워크 전체가 완성됨
- 서브넷 (pc1, pc2 → 허브) → 라우터

> **IP 주소**
> 
- **네트워크 번호 + 호스트 번호: 32비트**
    - **네트워크 번호**: 서브넷에 할당
    - **호스트 번호**: pc에 할당
- **넷마스크**
    - 네트워크 번호와 호스트 번호를 나누는 정보
    - 1인 부분 → 네트워크 번호, 0인 부분 → 호스트 번호
    - IP 주소 `10.1.2.3`, 넷마스크(`255.255.255.0`)
        - 네트워크 번호: 10.1.2.
        - 호스트 번호: 3
- **호스트 번호**
    - 모두 0: 서브넷 자체
    - 모두 1: 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트

### DNS

- IP 주소 기억하기 어려움 → 도메인명 사용
- 도메인명을 보내면 되지 않음?
    - → IP 주소는 32비트(4바이트)만 보내면 됨
    - → 도메인명(최대 255바이트)은 더 많은 시간이 걸림

### Socket 라이브러리의 리졸버

> **네임 리졸루션: DNS의 원리를 사용하여 IP 주소를 조사하는 것**
> 
- 가장 가까운 DNS 서버에 [example.co.kr](http://example.co.kr) 서버의 IP 주소 가르쳐주세요
- DNS 서버에 IP 주소 조회 메시지를 보내고, 응답 메시지를 받음

⇒ DNS 서버에 대해 클라이언트(**리졸버**)로 동작

> **리졸버: DNS 클라이언트**
> 
- Scoekt 라이브러리의 부품
- **Scoekt 라이브러리:** OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품집
- **리졸버 동작 과정**: 브라우저 → 소켓의 리졸버 → 프로토콜 스택(송신 담당) → LAN 어댑터 → DNS
    1. 브라우저가 리졸버 호출 → 리졸버가 프로토콜 스택을 통해 DNS 서버에 조회 메시지 보냄
    2. 리졸버는 응답 메시지 추출하여 브라우저에서 지정한 메모리 영역에 넣음
    3. 브라우저는 메모리 영역에서 IP 주소 추출하여 HTTP req msg와 함께 OS에 건네줌

## 03. 전  세계의 DNS 서버가 연대한다.

### DNS 서버 동작

> **DNS 서버에 조회**
> 
- 클라이언트가 DNS 서버에 조회 메시지(이름, 클래스, 타입)를 보냄
    - 이름: 서버명
    - 클래스: IN (INTERNET)
    - 타입: A, MX, PTR, CNAME, ..
- 조회 메시지와 모두 일치하는 IP 주소를 회답

> **DNS 서버에서 IP 주소 찾는 과정**
> 
- **도메인 계층:** `[www.cyber.co.kr](http://www.cyber.co.kr)` (kr → co → cyber → www)
- 상위의 DNS 서버에 하위의 DNS 서버 등록
- **루트 도메인 → 최상위 도메인 (com, kr) → 하위 도메인**
- 가장 가까운 DNS 서버에 액세스 → 루트 도메인을 경유 → 도메인의 계층 아래로 찾아가 최종 DNS 서버
- 캐시 기능
    - 한번 조사한 이름을 캐시에 기록
    - 등록 정보가 변경되는 경우도 있음 → 유효 기간 설정하여 지움

## 04. 프로토콜 스택에 메시지 송신을 의뢰한다.

```
💡 브라우저의 데이터 송신 동작: OS의 프로토콜 스택에 송신을 의뢰
- 소켓 작성 → 접속 → 송/수신 → 연결 끊기
```

### 데이터 송수신

> **데이터 송수신 동작 과정**
> 
1. 서버 측에서 소켓을 생성하고, 클라이언트가 해당 소켓에 파이프를 연결하기 기다림
2. 클라이언트에서 소켓을 만들고 파이프를 연결
3. 파이프를 통해 데이터를 부움

> **OS 내부의 프로토콜 스택에 메세지 송/수신 의뢰 과정**
> 
1. **소켓을 만든다 (소켓 작성 단계)**
    1. Socket 라이브러리의 `socket()` 호출 → 디스크립터 반환
    2. 디스크립터: 소켓을 식별하기 위한 번호
2. **서버측의 소켓에 파이프를 연결한다 (접속 단계)**
    1. Socket 라이브러리의 `connect()` 호출
    2. 디스크립터, 서버의 IP 주소, 포트 번호와 함께 호출
    3. IP 주소로 지정할 수 있는 범위는 어느 컴퓨터인가까지
    4. 컴퓨터의 소켓에 연결하기 위해서는 포트 번호 필요
    5. **디스크립터는 내부의 소켓을 식별하기 위함, 포트 번호는 상대측의 소켓을 식별하기 위함**
3. **데이터를 송/수신한다 (송/수신 단계)**
    1. 송신: Socket 라이브러리의 `write()` 호출
    2. 수신: Socket 라이브러리의 `read()` 호출
    3. 수신버퍼: 수신한 응답 메시지를 저장하기 위한 메모리 영역
4. **파이프를 분리하고 소켓을 말소한다 (연결 끊기 단계)**
    1. Socket 라이브러리의 `close()` 호출
    2. 응답 메시지 송신을 완료했을 때, 웹 서버측에서 호출