# HTTP 리퀘스트 메시지를 작성한다.

### 1️⃣ URL입력

URL이란 Uniform Resources Locator 로써 자원 위치를 알 수 있다. 비슷한 의미로 URI도 있는데 Identifier로 URL에 내포되어있는 것 중 하나이다.

브라우저는 http://, ftp:// 등등의 URL을 통해 어떤 데이터에 액세스하면 좋을 것인지를 판단 한다.

현재 인터넷에서 URL을 사용하는 주요 방법으로는 **서버의 도메인명, 파일 경로명, 포트 번호, 프로토콜** 을 작성하는 것이다.

```jsx
* HTTP 프로토콜로 웹 서버에 엑세스하는 경우
  http://user:password@www.cyber.co.kr:80/dir/file1.htm

  * FTP 프로토콜로 파일을 다운로드하거나 업로드하는 경우
  ftp://user:password@ftp.cyber.co.kr:21/dir/file1.htm

  * 클라이언트 PC 자체의 파일에서 데이터를 읽어오는 경우
  file://localhost/c:/path/file1.zip

  * 메일을 송신하는 경우
  mailto:tone@cyber.co.kr

  * 뉴스그룹의 기사를 읽는 경우
  news:comp.protocols.tcp-ip
```

공통점은 URL 맨앞에 액세스하는 프로토콜을 입력하는 것이다.

### 2️⃣ URL 해독

브라우저는 웹 서버에 리퀘스트 메시지를 작성하기 위해 URL을 해독한다.

```jsx
http://www.donghae.co.kr/dir1/donghae.html
[ http ]: + [ // ] + [ 웹 서버명 ] + [ / ] + [ 디렉토리명 ] +[ / ] + .... + [ 파일명 ]
```

웹 서버명 이후는 파일 경로에 접근한다는 의미이다.

### 3️⃣ 파일명 생략

파일 명이 /dir1/donghae.html이 아닌 **/dir1/** 로 종료될 수 있다. **/dir1** 처럼 종료될 수도 있다.

끝에 /가 존재하지 않을경우 디렉토리,파일명 인지 이해하지 못하기에 파일 존재시 파일, 디렉토리 존재시 디렉토리로 확인한다.

이와 같이 파일명을 생략할 수 있다. 어떤 파일에 접근해야할지 모르기에 생략 시 어떤 파일로 접근해야할지 설정해두어야한다.

ex) index.html

### 4️⃣ HTTP 기본 개념

> **Hyper-Text Transfer Protocol(HTTP)란 지정된 규약을 지켜 웹 서버와 데이터를 주고받는 서버/클라이언트 모델을 따르는 비연결성 & 무상태 프로토콜이다.

비 연결성 - 연결을 유지하지 않는 것 특정한 옵션을 주면 일정시간동안 연결을 유지할 수는 있다.
무 상태성 - 서버가 클라이언트의 상태를 보존하지 않는 것 매번 요청에 모든 상태값들을 전달해줘야 함 상태를 유지해줘야 할 경우 쿠키나 세션을 사용 함**
>

**왜 무상태성 ?**

비용을 줄이기 위해서다. 상태가 없는 대신 클라이언트에서 한번에 데이터를 제공해줘야한다.

URL 해석 이후 HTTP 프로토콜을 사용하여 웹 서버에 접근한다.

**HTTP 프로토콜 이란 ?**

클라이언트와 서버가 주고 받는 메세지의 내용이나 순서를 정한 것

요청 메세지 - URI , 메소드

응답 메세지 - 상태 코드 등

GET, POST, HEAD, OPTIONS, PUT, DELETE, CONNECT 등

### 5️⃣ HTTP 리퀘스트 메시지를 만든다

**요청**

리퀘스트 메세지의 첫 행 **리퀘스트 라인**을 기반으로 요청의 내용을 알 수 있다.

이후 한 행 씩을 헤더 필드로 사용한다.

이후에 메세지 본문을 넣는다.

**응답**

상태 코드의 내용을 나타낸다.

이후 한 행 씩을 헤더 필드로 사용한다.

이후에 메세지 본문을 넣는다.

헤더 필드

- 날짜, 클라이언트 취급 데이터 종류, 언어, 압축 형식
- 소프트웨어 명칭, 버전, 데이터 유효기간, 등
- 우리가 주로 사용했던 것은 Authorization, Date

### 6️⃣ 요청 메세지를 보내면 응답이 되돌아온다.

응답은 정상 종료, 오류 발생 등을 첫 행에 작성해야 한다.

요청 메세지에는 1개의 URI만 입력 가능함으로, 한 페이지에 여러 영상이 있다면 여러 요청을 웹서버에 보내야한다. 이는 브라우저가 잘 조정해서 진행해야한다.

웹 서버는 클라이언트가 어떻게 진행되던지 상관없이 한 요청에 한 응답만 보내면 될 뿐이다.

---

# 웹 서버 IP주소를 DNS서버에 조회한다.

### 1️⃣ IP주소의 기본

브라우저는 HTTP메세지를 네트워크에 송출할 수 없기에 OS를 통하여 메세지를 송신한다.

이때 도메인 주소가 아닌, IP주소로 메세지 대상을 지정해야한다.

IP주소를 사용하는 이유는 라우터의 부하 때문이다. IP주소는 32비트로 4BYTE 정도 크기지만, 도메인 주소는 더 크다.

서브넷 주소 + 컴퓨터에 할당된 케트워크 번호 주소 → IP 주소

1. 송신 측에서 허브(패킷 중계 장치)를 거쳐 가장 가까운 라우터(패킷 중계 장치)로 이동한다.
2. 라우터가 송신자를 확인 후 다음 라우터를 판단하고 송신 동작을 진행한다.
3. 이 동작을 반복하여 상대의 데이터가 도착한다.

우리는 IP를 8비트씩 점으로 구분하여 10진수로 표기한다. 이 형태가 IP주소인데 이는 네트워크 번호와 호스트 번호 가 합쳐져서 구별할 수는 없다. 그래서 이 내역을 나타내는 정보로써 ip주소에 덧붙이는 정보가 **넷마스크** 라고 한다.

**넷마스크로 네트워크번호, 호스트 번호의 경계를 만든다.**

- 호스트 번호가 0 이면 **서브넷** 자체를 나타낸다.
- 호스트 번호가 모두 1이면 서브넷 기기 전체에 패킷을 보내는 **브로드 캐스트**를 나타낸다.

### 2️⃣ 도메인명과 IP 주소를 구분하여 사용하는 이유

URL의 서버 도메인 명을 사용하는 것은 기억하기 어렵다.

그래서 IP 주소를 사용한다면 메세지 대상을 지정할 때도 IP주소말고 이름으로 하면 안될까 ?

**IP주소는 32비트 의 개수밖에 없지만, 도메인 명은 수십BYTE~ 255BYTE까지 있다. 그만큼 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸리며 네트워크 속도가 줄어든다. 현명한 방법이 아니다.**

IP주소를 알면 이름을 알 수 있다는 원리를 사용하여 양쪽의 차이를 해소하는 방법이 DNS 이다.

### 3️⃣ 소켓 라이브러리가 IP 주소를 찾는 기능을 제공한다.

가장 가까운 DNS 서버에 서버 IP주소를 알려달라고 질문한다.

브라우저는 어떻게 DNS 서버를 조회할 수 있을까 ?

DNS 서버를 조회한다는 것은 DNS 서버에 조회메세지 보내고, 응답 메세지를 받는 것이다.

이 DNS 클라이언트를 **DNS 리졸버, 리졸버**라고 부른다. DNS의 원리를 사용하여 IP 주소를 조사하는 것은 **name resolution** 이라고 한다. 이 **resolution**을 실행하는 것이 **resolver**다.

resolver는 socket 라이브러리에 들어있는 프로그램이다.

소켓 라이브러리란 OS에 포함되어 있는 네트워크 기능을 애플리케이션에서 호출하기 위한 기능이며, RESOLVER는 그중하나이다.

### 4️⃣ 리졸버를 이용하여 DNS 서버를 조회한다.

```jsx
<메모리 영역> = 리졸버프로그램명("조회하는서버 도메인명")
```

을 통해 리졸버를 호출한다.

이렇게 리졸버를 호출하면, 리졸버가 dns서버에 조회메세지를 보내고, 응답메세지가 돌아온다.

리졸버는 응답 메세지속 ip주소를 추출하여 브라우저의 메모리 영역에 써넣는다.

### 5️⃣ 리졸버 내부의 작동

리졸버의 프로그램명(gethostbyname)과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다.

1. 브라우저 애플리케이션이 Socket 라이브러리의 리졸버를 호출한다. 이때 gethostbyname에 웹서버 이름을 전달한다.
2. 리졸버가 DNS 서버에 조회 메세지를 보낸다. 메세지 송신 동작은 OS 내부의 프로토콜 스택을 호출하여 수행한다.
3. DNS 서버에서 돌아온 응답 메세지를 수신한다.
4. 응답 메세지에서 IP 주소를 추출하고 메모리 영역에 저장한 뒤 애플리케이션으로 돌아간다.

DNS 서버에 메세지를 송신할 때도 DNS 서버의 IP 주소가 필요한데, 이는 컴퓨터의 TCP/IP 설정 항목의 하나로 컴퓨터에 미리 설정되어 있다.

애플리케이션 → SOCKET → OS 내부 프로토콜 스택→ DNS 서버 → OS 내부 프로토콜 스택 → SOCKET → 애플리케이션 순

---

# 전 세계의 DNS 서버가 연대한다.

### 1️⃣ DNS 서버의 기본 동작

클라이언트에서 조회 메세지를 받고 조회의 내용을 응답한다.

조회 메세지에는

- 이름
    - 서버의 메일 배송 목적지와 같은 이름, 도메인 명
- 클래스
    - 네트워크 종류를 검토하기위해 사용되는 것 현재는 인터넷 외의 네트워크는 소멸되었기 때문에 항상 인터넷을 나타내는 IN 값이 전달된다
- 타입
    - 이름에 어떤 타입의 정보가 지원되는지를 나타낸다. 타입이 A이면 이름에 IP 주소가 지원되는 것을 나타내고 MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다. 타입에 따라 클라리언트에 회답하는 정보의 내용이 달라진다.

1. DNS가 메세지를 수신하면 DNS 서버는 이름, 클래스, 타입의 값이 일치하는 데이터를 찾는다.
2. 일치하는 데이터가 있으면 요청 값에 맞는 데이터를 클라이언트에게 전송한다. (예제를 기준으로 하면 192.168.2.5)

**DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다.**

### 2️⃣ 도메인의 계층

조회 메세지를 받았을 때 그 DNS 서버에 등록되지 않았을 수 도 있다.

다수의 DNS 서버에 등록되어 있는것을 다수의 DNS서버가 연대하여 정보를 찾아내는 구조이다.

https://eastc.tistory.com/ 에서 . 이 계층을 구분한다고 할 수 있다. COM도메인 아래에 TISTORY 아래에 EASTC라는 것이 있는 것이다.

### 3️⃣ 담당 DNS 서버를 찾아 IP 주소를 가져온다.

접근 대상 웹서버가 어느 DNS에 등록되어있는지를 알아내야한다.

하위 도메인을 담당하는 DNS 서버 IP주소를 그 상위 DNS 서버에 등록한다. 반복한다. 상위의 DNS 서버를 가면 하위의 DNS 서버의 IP 주소를 알 수 있다.

**이러한 방식은 상위 DNS 서버에서 하위의 DNS 서버의 IP 주소를 알 수 있다. (루트 도메인을 모든 DNS 서버에 등록하면 루트 도메인의 모든 하위 DNS 서버를 조회할 수 있음)**

1. 가장 가까운 DNS 서버에게 해당 도메인 명의 IP를 요청한다.
2. IP가 등록되어있지 않을 경우 루트 도메인 서버에게 해당 IP를 요청한다.
3. 루트 도메인에도 해당 IP가 등록되지 않았을 경우 하향식으로 접근하여 IP를 찾을 때까지 하위 도메인 서버에 해당 IP 정보를 요청한다.

### 4️⃣ DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.

위의 내용은 현실과 다른 부분이 있을 수 있다.

현실 인터넷은 한대의 DNS 서버에 복수 도메인 정보를 등록할 수 있다. 그래서 각 도메인에 한대씩 DNS 서버가 존재한다고 단정할 수 없다.

현실에서는 상위,하위 도메인을 같은 DNS 서버에 등록할 수 있다.

또한 DNS 서버는 한번 조사한 이름을 **캐시**(고속 기억장치에 저장)에 기록한다.

캐시에서 주의할 점은 캐시에 정보를 저장한 후 등록 정보가 변경될 수 있으므로 올바르다고 단언할 수 없다. DNS 서버에 등록하는 정보에는 유효기한을 정하고 삭제해야한다.

---

# 프로토콜 스택에 메시지 송신을 의뢰한다.

### 1️⃣ 데이터 송 수신 동작 개요

IP 주소를 알았으면 접근 대상 웹서버에 메세지를 송신하도록 OS 내부 프로토콜 스택에 의뢰한다.

Socket 라이브러리를 사용한다.

1. 서버측에서 소켓을 생성하고 클라이언트가 파이프를 연결하기를 기다린다. (소켓 생성 단계)
2. 클라이언트가 서버측 소켓에 파이프를 연결한다 (소켓 접속 단계)
3. 연결이 성공하면 데이터를 송 수신 한다 (송 수신 단계)
4. 송 수신 동작이 끝나면 파이프 연결을 해제한다. (연결은 클라이언트, 서버 둘 중 어느 쪽에서 분리해도 상관없다.)

### 2️⃣ 소켓의 작성 단계

socket()

- 소켓을 생성하고 완료되면 제어권을 애플리케이션에게 넘긴다. 소켓이 생성되면 **디스크립터**가 반환되는데, 이는 소켓을 식별하기 위한 식별자의 용도로 사용된다. 복수의 소켓이 있다면 이를 식별해야한다.

connect()

- 디스크립터, 서버의 IP 주소, 포트번호 세 가지 값을 입력하여 특정 소켓에 연결을 요청한다.
- 접속 동작을 실행한다. 연결 되면 연결 상대 ip주소, 포트번호를 소켓에 기록하여 데이터 송수신이 가능한 상태를 만든다.

포트 번호를 통해 접속 상대측 소켓을 식별할 수 있다. 포트번호는 따로 규칙이 있다. 웹은 80 메일은 25 등

wirte()

- 송신 데이터를 메모리에 할당하고 wirte() 함수를 호출할 때 디스크립터와 송신데이터를 지정한다. 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명된다.

read()

- 메세지를 수신할 때 사용된다. 수신한 응답메세지는 수신 버퍼에 저장된다. 수신버퍼는 애플리케이션 내부에 마련된 메모리 영역이므로 수신 버퍼에 메세지를 저장한 시점에 애플리케이션에게 메세지를 넘겨준다.

close()

- 메세지 송 수신이 완료되면 연결을 종료하는 함수 만약 read 동작을 수행하고 있는 도중에 연결이 종료되면 수신한 데이터를 건네주고 연결을 종료한다.
