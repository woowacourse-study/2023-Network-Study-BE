## 1. 소켓을 작성한다.

### 1. 프로토콜 스택 내부 구성

**네트워크 어플리케이션**

- 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램이 여기에 해당됨
- 네트워크 어플리케이션부터 아래로 향하여 데이터 송 수신 등의 일을 의뢰한다. 송 수신 동작은 모든 애플리케이션이 공통이다.
- Socket
    - Socket 라이브러리는 DNS서버에서 목적지의 IP 주소를 조회하는 역할을 담당한다.

**프로토콜 스택**

- 프로토콜 스택은 OS 내부에 존재하는 네트워크 제어용 소프트웨어이다.
- 프로토콜 스택의 윗단에는 TCP(일반적인 애플리케이션), UDP(짧은 제어용 데이터) 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 존재한다. 이 둘이 어플리케이션의 의뢰를 받아 송수신 동작을 실행한다.
- IP 프로토콜은 패킷을 통신 상대까지 운반한다.
    - ICMP는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메세지를 통지할 때 사용된다.
    - ARP는 IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용된다.

**LAN 드라이버**

- LAN 드라이버 아래에 있는 LAN 어댑터가 실제 송 수신 동작, 즉 케이블에 대해 신호를 송 수신 하는 동작을 실행함

### 2. 소켓의 실체는 통신 제어용 제어 정보

프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있다. 해당 영역에는 통신 동작 제어에 필요한 제어 정보를 기록한다. **통신 상대의 IP주소, 포트번호, 통신 동작 진행 상태** 등이 있다. 이 영역을 소켓이라 할 수 있다.

프토콜 스택은 이 제어 정보를 참조하면서 동작한다.

소켓을 만든 다는 것은 메모리에 제어 정보를 추가하고 기록해 두는 통신을 준비하는 작업이다.

### 3. 소켓을 호출했을 때의 동작

애플리케이션이 socket을 호출 시 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 초기 상태임을 나타내는 제어 정보를 기록한다. 이 과정을 통해 소켓이 생성된다. 그 후 소켓 디스크립터를 애플리케이션에 알린다. 이후 이 디스크립터를 이용하여 소켓을 지정한다.

## 2. 서버에 접속한다.

### 1. 접속의 의미

접속 이란 ?

- 통신 상대와의 사이에 제어 정보를 주고받아 소켓 필요한 정보를 기록하고 데이터 송 수신 가능한 상태로 만드는 것
- 송 수신 데이터를 일시적으로 저장할 버퍼 메모리 확보

### 2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.

제어 정보는 다양하다.

클라이언트와 서버 사이에 주고받는 패킷 맨 앞부분에 제어 정보 헤더를 부가한다.

헤더는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 정보가 포함되어 있다. 이더넷이나 IP에도 동일한 헤더가 존재하기 때문에 **TCP 헤더, 이더넷 헤더(=Mac 헤더), IP헤더**와 같이 구분하여 사용해야 한다.

### 3. 접속 동작의 실체

connet() 를 통해 **서**버측의 IP 주소와 포트 번호를 입력하면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다. TCP 는 목적지 서버측의 TCP 담당 부분과의 사이에 제어 정보를 주고 받는다.

**클라이언트와 서버의 대화 과정**

1. 데이터 송 수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더가 만들어지면 이를 IP 담당 소프트웨어에 건네주어 송신하도록 의뢰한다.
2. 송신 동작을 거쳐 네트워크를 통해 서버에  패킷이 도착하면 서버측의 IP 담당 소프트웨어가 이를 TCP 담당 소프트웨어 에게 전달한다.
3. 서버측의 TCP SW가 TCP헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾고 발견되면 해당 소켓에 필요한 정보를 기록하고 접속 동작 상태를 진행 중으로 변경한다.
4. 서버의 TCP 담당 소프트웨어는 응답을 돌려보내기 위해 IP 담당 소프트웨어에게 의뢰한다.
5. 이때 ACK라는 컨트롤 비트도 1로 설정하여 돌려보낸다.
6. 패킷이 클라이언트에게 정상적으로 돌아왔으면 클라이언트는 TCP 헤더의 ACK를 조사하여 서버측의 접속 동작이 성공했는지 확인한다.
7. 마지막으로 클라이언트에 패킷이 정상적으로 도착했다는 것을 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 서버측에 반송한다.

## 3. 데이터를 송수신 한다.

### 1. **프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다.**

connect 이후 write()를 호출하여 송신 데이터를 프로토콜 스택에 건네준다.

프로토콜 스택은 받은 데이터의 내용을 곧바로 송신하는 것이 아닌 프로토콜 스택 내부의 송신용 버퍼 메모리 영역에 저장하고 다음 데이터를 건네주기를 기다린다.

송신용 버퍼에 저장하는 이유는 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션마다 상이하기 때문이다. 데이터를 곧바로 보내는 방법은 작은 패킷을 많이 보낼 수 있지만 네트워크 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 나서 송 수신 동작을 진행한다.

**MTU**나 **타이밍**을 바탕으로 송신 버퍼에 어느정도 쌓이고 전송되는지 판단할 수 있다.

**MTU** 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이 이더넷에서는 보통 1500 바이트 이다. MTU에는 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이 **MSS** 라고 한다.

**MSS** 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터 최대 길이이다.

**타이밍은** MSS에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 하는 것을 의미한다. 프로토콜 스택은 일정한 시간이 경과하면 패킷을 송신할 수 있게 내부에 타이머라는 소프트웨어를 둔다.

두 가지의 판단요소가 존재하지만 이 둘은 상반되는 면도 존재한다. 

**MSS** 바탕을 중시하면 패킷 길이가 길어져서 네트워크 이용 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 존재한다.

**타이밍**을 중시하면 지연은 적어지지만 이용 효율이 떨어지므로 양자를 절충해서 적당히 시간을 가늠하여 송신 동작을 실행해야 한다.

### 2. 데이터가 클 때는 분할하여 보낸다

HTTP 리퀘스트 메세지는 길지 않다. HTTP 리퀘스트 메세지가 한 개의 패킷에 전부 들어가지 못할 경우, 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고 분할한 조각을 한 개씩 패킷에 넣어 송신한다.

### 3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다.

TCP는 송신한 패킷이 상대에게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.

먼저 TCP 담당 소프트웨어는 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당 하는지 세어둔다. 이 값을 **시퀀스 번호**라고 하며 TCP 헤더에 기록한다. 이렇게 시퀀스 번호를 기록할 경우 수신측에서 패킷의 누락여부를 확인할 수 있다. 수신측은 전달 받은 데이터의 바이트 크기를 확인하고 이를 ACK 번호에 기록하고 이 값에 1을 더하여 송신측에 전달한다. 이것을 **수신 확인 응답**이라고한다.

만약 시퀀스 번호가 누락되었다면 전송이 제대로 이뤄지지 않았기 때문에 재전송한다.

SYN을 통해 데이터가 초기 값이라는 것을 나타낼 수 있다.

이 구조를 통해 패킷이 올바르게 도착한 것을 확인하고 오류 발생시 회복처리가 좋다.

근데 궁금한 것은 1~10 패킷 중에 1번만 누락되었을 경우에 1~10까지 다시 순서대로 보내나 ? 그럼 너무 비효율적아닌가 ? 그리고 시퀀스 번호 초기값이라는 것은 서버측과 클라이언트측 서로 다르겠지 ?처음값은 ?

### 4. **패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.**

ACK 번호가 돌아오는 것을 기다리는 시간을 **타임아웃 값** 이라고 한다. 네트워크가 혼잡하면 ACK 번호가 돌아오는 시간이 지연될 수 있다.

이러한 문제를 방지하기 위해 대기 시간을 적절하게 설정해야한다. 대기 시간이 너무 짧으면 패킷을 자주 보내게 되고 대기시간을 너무 길게 설정하면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 되기 때문이다.

ACK 번호가 돌아오는 시간에 따라 동적으로 대기시간을 늘리고 줄인다.

### 5. **윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.**

ACK 번호가 돌아올 때까지의 시간동안 아무 일도 하지 않고 기다리는 것은 자원과 시간 낭비이다.

윈도우 제어 방식이란 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법을 말한다. 이럴 경우 ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.

주의할 점은 ACK 번호를 기다리지 않고 차례로 패킷을 보내면 수신측의 능력을 초과하여 패킷을 보내는 사태가 발생할 수 있다.

수신측은 패킷을 수신하면 수신측 버퍼 메모리에 일시 보관한다. 하지만 송신측이 수신측의 처리속도보다 빠른 속도로 패킷을 송신하면 수신 버퍼에 데이터가 쌓이지 않고 사라질 수 있다.

이러한 문제를 방지하기 위해 수신측은 송신측에 수신가능한 데이터의 양을 통지한다. 수신 가능한 양은 TCP 헤더의 윈도우 필드에 기록하여 송신측에 알린다.

### 6. **ACK 번호와 윈도우를 합승한다.**

윈도우 통지는 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때 빈 영역이 늘어났을때 송신측에 통지해야한다. 이것이 윈도우 통지 타이밍이다.

수신측은 네트워크 효율성 저하를 방지하기 위해 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다린다. 기다리는 사이에 통지 동작이 발생하면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 전송한다.

ACK 번호는 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK 번호가 통지가 연속적으로 발생하면 마지막 ACK 번호만 송신하고 나머지의 것은 생략해도 상관없다. 윈도우 통지도 마찬가지이다. 윈도우 통지가 연속적으로 발생하면 수신버퍼에 빈 공간이 늘어난다는 의미이므로 마지막 통지만 전달해도 문제가 발생하지 않는다.

### 7. **HTTP 응답 메세지를 수신한다.**

데이터를 수신하면 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 누락된 데이터가 있는 지 검사하고 문제가 없으면 송신측에 ACK 번호를 반송한다. 그리고 데이터의 조각을 수신 버퍼에 일시 보관하고 데이터 조각을 연결하여 애플리케이션에게 건네준다. 이를 정확하게 설명하자면 수신 버퍼에 저장된 데이터를 애플리케이션 메모리 영역에 옮기고 제어권을 애플리케이션에게 되돌려준다.

## 4. 서버에서 연결을 끊어 소켓을 말소한다

### 1. 데이터 보내기를 완료했을 때 연결을 끊는다

애플리케이션이 데이터를 전부 송신하면 연결 끊기 단계로 들어는데, 어디에서 송수신 동작이 끝나는지는 애플리케이션에 따라 다르다.

- 서버측 애플리케이션이 Socket 라이브러리의 close를 호출한다.
- 서버측 프로토콜 스택이 TCP 헤더에 FIN 1을 설정하고 IP 담당 부분에 의뢰하여 클라이언트에게 송신한다.
- 서버에서 FIN 1로 설정된 TCP 헤더가 도착하면 클라이트언트의 프로토콜 스택이 서버가 연결 끊기에 들어간 것을 알게 된다.
- ACK 번호를 서버에 반송하고 애플리케이션이 데이터를 가지러 오길 기다린다.
- 애플리케이션이 read로 데이터를 가지러 오면, 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 것을 클라이언트 애플리케이션에게 알린다.
- 서버에서 보낸 데이터를 모두 수신했으니, 클라이언트도 close를 호출해 연결 끊기 동작으로 들어간다.
- 클라이언트 프로토콜도 서버측과 마찬가지로 FIN에 1을 설정한 TCP 헤더를 만들고 서버에 송신, 서버에서 ACK 번호가 돌아오면 연결이 끝난다.

### 2. 소켓을 말소한다

연결을 끊고 소켓이 당장 필요 없지만, 소켓을 바로 말소하진 않고 오동작을 막기 위해 잠시 대기 후에 말소시킨다.

## 5. IP와 이더넷의 패킷 송 수신 동작

### 1. 패킷의 기본

패킷은 헤더와 데이터로 구성되어있다. 헤더는 제어정보, 데이터는 전송내용이다.

중계장치는 패킷의 헤더를 조사하여 수신처를 알아내고 송신한다. 이 중계장치는 송신,수신을 모두 하므로 **엔드 노드**라고 불리운다.

TCP/IP는

1. 라우터(ip)가 목적지를 확인하여 다음 라우터(ip)를 나타낸다.
2. 허브(서브넷) 안에 있는 이더넷이 (라우터)중계장치까지 패킷을 운반한다.

mac 헤더는 라우터가 패킷을 중계할때마다 바꾸며, 수신처로써 사용한다.

이렇게 역할을 분담한 이유는 이더넷 부분이 무선lan,adsl등 다른 것으로 대신 사용될 수 있다. 그래서 ip와 조합하여 사용한다면 적재적소에 사용가능하다. 유연성이있다.

### 2. 패킷 송 수신 동작 개요

ip담당은 패킷을 송출만한다. 운반은 허브,라우터 같은 네트워크 기기역할이다. ip 담당부분은 mac 헤더와 ip 헤더를 패킷에 이어붙여 tcp/ip 패킷을 만드는 역할을 한다.

이것이 lan 어댑터로 전송되고 넘어간 데이터는 0,1 비트가 이어진 디지털 데이터이다. 전기,빛 신호로 케이블에 송출된다.

### 3. 수신처 ip 주소를 기록한 ip 헤더를 만든다.

ip 부분은 ip 헤더를 만들어 tcp 헤더앞에 붙인다. 이 데이터에는 애플리케이션에서 설정한 수신처 ip 주소가 있다. 그리고 송신처 ip 주소도 설정한다.

interface 란 lan 어댑터 등의 네트워크용 인터페이스를 나타내고, 인터페이스에서 패킷을 송신하면 패킷전달해줄수 있다는 것이다.

gateway란 다음 라우터의 ip 주소를 기록하여 ip 주소를 가진 라우터에 패킷을 주면 라우터가 목적지에 패킷을 중계해준다.

이것으로 어느 lan 어댑터에서 패킷을 송신해야하는지 알고 송신처 ip 주소로 설정 가능하다.

### 4. 이더넷용 mac 헤더를 만든다.

이더넷에는 tcp/ip 개념이 통용되지 않는다. 특정 구조를 따라야하는데 이더넷 수신처 판단 구조로 사용되는 것이 mac 헤더이다.

mac주소는 48비트의 하나의 값이다. 이더 타입은 사용하는 프로토콜의 종류를 나타낸다. tcp/ip 통신에 사용되는 값은 0800 0806이다.

수신처 mac주소는 처음에는 값이 없지만 gateway 항목에 기록되어있는 ip 주소를 통해 상대의 mac 주소를 찾아야한다.

### 5. arp로 수신처 라우터의 mac 주소를 조사한다.

arp라는 이더넷에 연결된 전원에게 패킷을 전달하는 브로드 캐스트를 이용하여 mac 주소를 찾는다.

한번 조사한 결과는 arp 캐시 메모리 영역에 보존하여 다시 이용한다. 이는 시간이 지나면 삭제한다.

### 6. 이더넷의 기본

이더넷은 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술이다.

케이블 사이에서 신호를 흘리기만한다. 신호 앞부분에 수신처 주소를 적어둠으로써 원하는 상대에게만 패킷이 이동하도록 한다.

요즘은 스위칭 허브를 사용한 형태를 사용한다. 수신처 mac 주소로 나타내는 원하는 기기로만 신호가 흐른다.

**mac 헤더 수신처 mac 주소로 패킷을 전달하고, 송신처 mac 주소로 송신처를 나타낸 후 이더타입으로 패킷 내용물을 나타낸다.**

### 7. ip 패킷을 전기,빛 신호로 변환하여 송신한다.

ip 패킷은 메모리에있는 디지털 데이터이므로 상대에게 보낼 수 없다. 그래서 디지털 데이터를 전기,빛 신호로 변환하여 송출해야한다.

이것을 lan 어댑터가 실행한다.

LAN 어댑터는 버퍼 메모리(패킷 일시 저장) → MAC(이더넷 송수신 동작 제어) → PHY(신호 송신,수신 회로 합친 것) → 커넥터(lan 케이블 연결) 순으로 연결된다.

### 8. 패킷에 3개의 제어용 데이터를 추가한다.

LAN 드라이버는 패킷을 메모리에 복사한다. 그 후 mac 회로의 작업이 시작된다.

버퍼 메모리에서 추출 한 패킷의 앞에 프리앰블, 스타트 프레임 딜리미터 라는 데이터와 맨 끝에는 프레임 체크 시퀀스 라는 오류 검출용 데이터를 부가한다.

프리앰블은 송신하는 패킷을 읽을 때 타이밍을 잡기 위한 것이다.

디지털 데이터를 전기 신호로 나타낼때는 0과 1의 값을 전압 전류 값에 대응시켜야 하는데 이 과정에서 그냥 데이터 신호만 사용한다면 구별하기 어려워짐으로 클록신호 + 데이터 신호를 사용하여 구별한다. 나중에는 클록신호를 분리하면된다.

이때 클록 신호의 타이밍을 판단하는 것이 중요한데, 클록신호의 타이밍을 잡기 위한 신호가 프리앰블의 역할이다. 수신쪽에서 프리앰블에 이어지는 스타트 프레임 딜리미터를 보고 신호에서 데이터를 추출한다. 이것이 결국 패킷의 시작을 나타낸다. fcs 는 패킷운반 도중 파형이 흐트러져 데이터가 변한 경우 이것을 검출하기 위해 사용하는 것이다.

여기 좀 치네요 ;

### 9. 허브를 향해 패킷을 송신한다.

프리앰블, 스타트 프레임 딜리미터, fcs 세가지를 부가하면 케이블에 송출하는 패킷이 완성된다. 신호를 송신하는데 리피터 허브 사용하는 반이중 모드, 스위칭 허브를 사용한 전이중 모드가 있다.

반이중 모드란 신호의 충돌을 피하기 위해

케이블에 다른 신호가 있는지 조사하고, 흐른다면 기다린다. 흐르고 있을때 송신하면 충돌하기 때문이다. 이 송신 동작은 mac 회로가 프리앰블 앞 1비트씩 전기 신호로 변경하고 phy,mau라는 부분에 보낸다.

phy(mau)회로는 이 신호를 케이블에 송출하는 형식으로 변환하여 송신한다. 이곳은 mac 회로가 송신한 신호의 형식을 변환하는 변환 회로이다. 수신 신호선에서 신호가 흘러들어오는지 감시한다. 신호 송신을 완료할 때까지 수신 신호선에 신호가 들어오지 않으면 송 수신 동작이 끝난다. 이더넷은 신호가 상대에게 완전히 도착했는지 확인하지 않는다. 반이중 모드에서 다른 신호가 들어오면 충돌이 일어난다. 충돌이 일어난 사실을 **재밍 신호**라는 특수 신호를 보낸다. 그 후 대기시간을 계산하고 보낸다. 충돌 시 마다 2배씩 대기 시간을 늘리고 10번째까지 보냈는데 해결안되면 오류라고 판단한다.

전이중 모드는 송수신이 동시에 실행하면서 충돌이 일어나지 않는다. 수신선에서 신호가 흘러와도 단순히 신호를 보내기만 한다.

### 10. 돌아온 패킷을 받는다.

신호 맨 앞 프리앰블을 통해 타이밍을 계산해서 스타트 프레임 딜리미터가 나오면 그 다음부터 디지털 데이터로 변환한다. phy 회로에서 신호를 변환하여 mac 회로로 보내고 여기서 디지털 데이터로 변환하여 버퍼 메모리에 저장한다. 그리고 fcs를 검사한다. 만약 패킷끝 fcs와 계산식이 일치하지 않는다면 오류 패킷으로 간주하여 폐기한다.

lan 어댑터 측에서 컴퓨터로 패킷 도착을 **인터럽트** 구조를 이용하여 알려줘야한다. cpu는 실행 작업을 일시적 보류하고 os 내부 인터럽트 처리용 프로그램으로 전환한다.

…

### 11. 서버의 응답 패킷을 ip에서 tcp 로 넘긴다.

ip 부분은 ip 헤더를 보고 문제 없는지 확인하고 문제시 icmp 라는 메세지를 사용하여 오류를 나타낸다.

수신한 패킷이 여러개라면 ip 부분이 그것을 원래 패킷으로 되돌린다. ip 헤더의 플래그와 id 정보, 프래그먼트 오프셋을 확인하여 리어셈블링한다.

tcp 담당 부분은 수신ip, 송신ip, tcp 헤더 수신처 포트번호 및 송신처 포트번호를 조사하여 소켓을 찾는다. 이후 수신 버퍼에 데이터를 저장하고 기다린다.

## 6. UDP 프로토콜을 이용한 송수신 동작

### 1. 수정 송신이 필요없는 데이터의 송신은 udp 가 효율적이다

tcp 가 복잡한이유는 확실한데이터, 효율적 전달 때문이다.

만약 1개의 패킷으로 처리 가능한 데이터라면 꼭 tcp처럼 복잡한 구조를 가져갈 필요가 없다.

### 2. 제어용 짧은 데이터

dns 조회 등 제어용 정보교환은 1개의 패킷이므로 udp를 사용한다.

udp 헤더를 부가하고 ip에 의뢰하여 송신하면 끝난다. 보낸 패킷의 상태를 감시하지 않는다.

### 3. 음성 및 동영상 데이터

음성,영상 데이터도 udp 를 사용한다. tcp 수신확인 응답을 사용하면 너무 오래걸린다. 그래서 데이터가 다소 없어도 치명적인 문제가 발생하지 않기에 udp로 데이터를 보낸다.
